#!/usr/bin/env python

import argparse
import os
import subprocess
import sys
from collections.abc import Iterable
from enum import IntEnum
from functools import cmp_to_key
from itertools import chain
from pathlib import Path
from typing import Any, NamedTuple

USER_INTERRUPT = 130

NF_DIRECTORY_ICON = '\uf413  '
NF_IMAGE_ICON = '\uf03e  '
NF_VIDEO_ICON = '\uf01d  '

icons = frozenset({NF_DIRECTORY_ICON, NF_IMAGE_ICON, NF_VIDEO_ICON})

PARENT_DIR_OPTION = NF_DIRECTORY_ICON + os.path.pardir

# Image formats supported by nsxiv
_extension_to_icon = {
    'avif': NF_IMAGE_ICON,
    'bmp': NF_IMAGE_ICON,
    'ff': NF_IMAGE_ICON,
    'gif': NF_VIDEO_ICON,
    'heif': NF_IMAGE_ICON,
    'ico': NF_IMAGE_ICON,
    'jpeg': NF_IMAGE_ICON,
    'jpg': NF_IMAGE_ICON,
    'jxl': NF_IMAGE_ICON,
    'pam': NF_IMAGE_ICON,
    'pbm': NF_IMAGE_ICON,
    'png': NF_IMAGE_ICON,
    'ppm': NF_IMAGE_ICON,
    'qoi': NF_IMAGE_ICON,
    'svg': NF_IMAGE_ICON,
    'tga': NF_IMAGE_ICON,
    'tiff': NF_IMAGE_ICON,
    'webp': NF_IMAGE_ICON,
}

extension_to_icon = {f'.{ext}': icon for ext, icon in _extension_to_icon.items()}
extension_to_icon.update(_extension_to_icon)

extensions = frozenset(_extension_to_icon.keys())
suffixes = frozenset(f'.{ext}' for ext in extensions)

del _extension_to_icon

PathLike = os.PathLike[str]


class DirContent(NamedTuple):
    directories: list[Path]
    files: list[Path]


class CmpResult(IntEnum):
    LESS = -1
    EQUAL = 0
    GREATER = 1


def extract_int(string: str, start: int) -> tuple[int, int]:
    index = start
    for index, char in enumerate(string[start:], start):
        if not char.isdecimal():
            break
    if start == index:
        char = string and f' ({string[index]})'
        raise ValueError(f'Tried to extract int from {string!r} at index {index}{char}')
    last_index = len(string) - 1
    if index == last_index and string[last_index].isdecimal():
        index += 1
    return int(string[start:index]), index


def cmp_to_int(o: Any, p: Any, /) -> CmpResult:
    if o < p:
        return CmpResult.LESS
    elif o == p:
        return CmpResult.EQUAL
    else:
        return CmpResult.GREATER


def version_compare(s1: str, s2: str, /) -> int:
    """Compare two strings, interpreting sequences of digits as integers."""

    if not s1 or not s2:
        return cmp_to_int(s1, s2)

    skip_until_index = -1
    min_length = min(len(s1), len(s2))

    for i, (char_1, char_2) in enumerate(zip(s1, s2)):
        if skip_until_index >= min_length:
            break
        if i < skip_until_index:
            continue

        if not char_1.isdecimal() or not char_2.isdecimal():
            result = cmp_to_int(char_1, char_2)
            if result is CmpResult.EQUAL:
                continue
            return result

        number_1, end_1 = extract_int(s1, i)
        number_2, end_2 = extract_int(s2, i)
        cmp_result = cmp_to_int(number_1, number_2)

        if cmp_result is not CmpResult.EQUAL:
            return cmp_result

        skip_until_index = min(end_1, end_2)

    return cmp_to_int(len(s1), len(s2))


def select_option(prompt: str, options: Iterable[str]) -> str | None:
    # File names may contain spaces at the end, so delimit them
    # using null bytes and strip them afterwards
    process = subprocess.run(
        ['fzf', '--print0', '--read0', '--no-sort', '--cycle', '--prompt', prompt],
        input='\0'.join(options),
        encoding='utf-8',
        stdout=subprocess.PIPE,
    )
    option = process.stdout.rstrip('\0')
    if process.returncode == USER_INTERRUPT or not option:
        return None
    return option


def view_images(image_paths: Iterable[PathLike], start_at: int = 0) -> bool:
    args = ['nsxiv', '--stdin', '--null', '--no-bar', '--animate']
    if start_at > 0:
        args.extend(('--start-at', str(start_at + 1)))
    paths = '\0'.join(map(os.fspath, image_paths))
    process = subprocess.run(args, input=paths, encoding='utf-8')
    return process.returncode == 0


def get_dir_contents(directory: Path) -> DirContent:
    content = DirContent([], [])
    for file in directory.iterdir():
        if file.is_dir():
            content.directories.append(file)
        elif file.is_file() and file.suffix in suffixes:
            content.files.append(file)
    return content


def get_icon(path: Path) -> str:
    if path.is_dir():
        return NF_DIRECTORY_ICON
    if path.is_file():
        return extension_to_icon[path.suffix]
    return ''


def strip_icon(string: str) -> str:
    for icon in icons:
        if string.startswith(icon):
            return string.removeprefix(icon)
    return string


@cmp_to_key
def path_sort_key(p: Path, q: Path) -> int:
    return version_compare(p.name, q.name)


def browse_contents(directory: Path) -> bool:
    root = directory
    selected_path = directory

    while True:
        in_root_dir = directory == root
        content = get_dir_contents(directory)
        content.directories.sort(key=path_sort_key)
        content.files.sort(key=path_sort_key)

        if in_root_dir and not content.directories and not content.files:
            print(f'{directory} is an empty directory, no files to browse', file=sys.stderr)
            return False

        if content.files and not content.directories and selected_path.is_dir():
            if not view_images(content.files):
                return False
            if in_root_dir:
                return True

        # Maybe refactor into a function?
        options = (get_icon(file) + file.name for file in chain(content.directories, content.files))
        if not in_root_dir:
            options = chain([PARENT_DIR_OPTION], options)

        option = select_option(f'{directory}❯ ', options)

        if option is None:
            return True

        # Calling `relative_to` after `resolve` may throw on symlinks
        path = directory / strip_icon(option)
        selected_path = path.resolve(strict=True).relative_to(Path.cwd())

        if selected_path.is_dir():
            directory = selected_path
        elif selected_path.is_file():
            index = content.files.index(selected_path)
            if not view_images(content.files, start_at=index):
                return False
        else:
            raise ValueError(f"You shouldn't be here: {path}")


def main() -> int:
    curdir = os.path.curdir
    parser = argparse.ArgumentParser(description='Browse images using `fzf` and `nsxiv`.')
    parser.add_argument('DIR', nargs='?', default=curdir, help=f'directory to browse (default: {curdir})')
    args = parser.parse_args()

    directory = Path(args.DIR)

    if not directory.is_dir():
        parser.error(f"{directory} doesn't exists or is not a directory")

    return 0 if browse_contents(directory) else 1


if __name__ == '__main__':
    sys.exit(main())
